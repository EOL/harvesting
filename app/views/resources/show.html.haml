.ui.top.attached.centered.brown.block.header
  %h1= @resource.name
.ui.tiny.attached.menu
  -# TODO: HACK! We need real secrets for this to work, argh:
  - id = WebDb.resource_id(@resource) rescue ''
  .item= link_to(t("resources.actions.publishing_side"), "http://eol.org/resources/#{id}")
  - if policy(@resource).update?
    .item= link_to(t("edit"), edit_resource_path(@resource))
    .item= link_to(t("delete"), @resource, method: :delete, data: { confirm: t("are_you_sure") })
  - if Delayed::Job.where(queue: 'harvest').where("handler LIKE '%resource_id: #{@resource.id}%'").any?
    .item= t("resources.actions.harvest_in_queue")
  - elsif policy(@resource).update?
    .right.menu
      .item
        .ui.buttons
          - if @resource.harvests.completed.any?
            .ui.compact.button
              = link_to(t("resources.actions.re_harvest"), resource_re_harvest_path(@resource), data: { confirm: t("resources.actions.re_harvest_confirm") })
          - elsif @resource.harvests.any?
            .ui.compact.button
              = link_to(t("resources.actions.resume_harvest"), resource_resume_harvest_path(@resource))
          - else
            .ui.compact.button
              = link_to(t("resources.actions.harvest"), resource_harvest_path(@resource))
          - if @resource.opendata_url
            .ui.compact.button
              = link_to(t("resources.actions.re_download_opendata_harvest"),
                resource_re_download_opendata_harvest_path(@resource),
                data: { confirm: t("resources.actions.re_download_confirm") })
          .ui.compact.button
            = link_to(t("resources.actions.re_create_tsv"), resource_re_create_tsv_path(@resource))
          .ui.compact.button
            = link_to(t("resources.actions.re_read_xml"), resource_re_read_xml_path(@resource))
          - if policy(@resource).destroy?
            .ui.negative.button
              = link_to(t("harvests.actions.destroy"), resource_path(@resource), method: :delete, style: 'color: white', data: { confirm: 'This is the resource, not the harvest. This CANNOT be undone. Are you SURE?' })
.ui.bottom.attached.segment
  .ui.list
    - unless @resource.abbr.blank?
      .item
        %strong= "Abbreviation:"
        = @resource.abbr
    - unless @resource.opendata_url.blank?
      .item
        %strong= "OpenData URL:"
        = link_to(@resource.opendata_url.sub(%r{^.*/}, ''), @resource.opendata_url)
    .item
      %strong= "Minimum Days Between Harvests:"
      = @resource.min_days_between_harvests
    - if @resource.harvest_day_of_month
      .item
        %strong= "Harvests on Day of Month:"
        = @resource.harvest_day_of_month
    - if @resource.harvest_months_json && ! @resource.harvest_months_json == ""
      .item
        %strong= "Harvests on Months:"
        - months = JSON.parse(@resource.harvest_months_json)
        = months.join(", ")
    .item
      %strong= "Harvesting Status:"
      - if @resource.publish_status.nil?
        = t("resources.publish_status.nil")
      - else
        = t("resources.publish_status.#{@resource.publish_status}")
    - if @resource.nodes_count
      .item
        %strong= "Nodes:"
        = @resource.nodes_count
    - else
      .item= "Nodes count is blank (this is not a problem, but is inconvenient)."
    .item
      %strong= "URLs for node IDs will direct the client to:"
      - if @resource.pk_url == "$PK"
        "(The ID itself: this assumes the IDs are valid URIs)"
      - else
        = @resource.pk_url.gsub("$PK", "[the identfier]")
    - if @resource.auto_publish?
      "This resource will auto-publish after harvesting."
    - else
      "This resource will NOT be published after harvesting. It must be published manually."
    .item
      %strong= "Trusted:"
      = @resource.not_trusted? ? "No." : "Yes."
    .item
      %strong= "Classification Resource:"
      = @resource.classification? ? "Yes." : "No."
    - if @resource.hold_harvesting?
      .item
        %strong= "THIS RESOURCE IS ON HOLD:"
        = "It will not be harvested until an admin releases this hold."
    .item
      %strong= "May Contain Duplicate Taxa:"
      = @resource.might_have_duplicate_taxa? ? "Yes." : "No."
    - if @resource.force_harvest?
      .item
        %strong= "THIS RESOURCE WILL BE HARVESTED ASAP:"
        = "An admin has set this resource to Force Harvest."
    .item
      %strong= "Created:"
      = I18n.l @resource.created_at.localtime, format: :short
    .item
      %strong= "Last Updated:"
      = I18n.l @resource.updated_at.localtime, format: :short

%h2= "Expected File Format Definitions"
- if @formats.empty?
  .ui.section= "This resource has no file format definitions yet, and cannot be harvested."
- else
  %ul
    - @formats.each do |fmt|
      .item
        %strong= "#{link_to(fmt.represents, fmt)}:".html_safe
        = fmt.get_from
        - if fmt.excel?
          = ", sheet ##{fmt.sheet}"
        = "(#{fmt.fields.size} fields)"
        - lines = `wc -l #{fmt.get_from.gsub(/(\s)/, "\\\1")}`.split.first
        = "(#{lines} lines)"
.ui.section
  = link_to(t("resources.show.add_format"), new_resource_format_path(@resource))
%h2= "Harvests"
- if @resource.removing_content?
  .ui.raised.segment
    %p
      %b
        Content is currently being removed.
      This can take a VERY long time, please be patient.
- if @resource.harvests.empty?
  This resource has not been harvested.
- else
  %ul
    - @resource.harvests.order(created_at: :desc).each do |harv|
      .item= render('harvests/show', harv: harv)
%h2= "Content"
- media_count = @resource.media.published.count
.ui.segment
  .ui.six.tiny.statistics
    .statistic
      .value= @resource.nodes.published.count
      .label= t("resources.stats.nodes")
    .statistic
      .value= @resource.articles.published.count
      .label= t("resources.stats.articles")
    .statistic
      .value= @resource.identifiers.count
      .label= t("resources.stats.identifiers")
    .statistic
      .value= media_count
      .label= t("resources.stats.media")
    .statistic
      .value= @resource.references.published.count
      .label= t("resources.stats.references")
    .statistic
      .value= @resource.scientific_names.published.count
      .label= t("resources.stats.scientific_names")
  .ui.six.tiny.statistics
    .statistic
      .value= Trait.where(harvest_id: @resource.harvest_ids).published.count
      .label= t("resources.stats.traits")
    .statistic
      .value= Assoc.where(harvest_id: @resource.harvest_ids).published.count
      .label= t("resources.stats.associations")
    .statistic
      .value= @resource.vernaculars.published.count
      .label= t("resources.stats.vernaculars")
    .statistic
      .value= @resource.downloaded_media_count
      .label= t("resources.stats.downloaded_media_count")
    .statistic
      .value= @resource.failed_downloaded_media_count
      .label= t("resources.stats.failed_downloaded_media_count")

- if media_count.positive?
  .ui.segment
    - pct = ((@resource.downloaded_media_count / media_count.to_f) * 100).ceil
    #progress.ui.progress{ data: { percent: pct } }
      .bar
        .progress
      .label= t("resources.stats.downloaded_media_progress", count: pct)

%h2= t(:resource_nodes_title)
- if @resource.nodes.published.empty?
  %p This resource has no nodes.
- else
  %h3= t(:resource_nodes_root_head_count, count: @resource.nodes.root.count)
  = paginate(@root_nodes)
  .ui.list
    - @root_nodes.each do |root_node|
      .item= link_to(root_node.canonical || root_node.resource_pk, root_node)
